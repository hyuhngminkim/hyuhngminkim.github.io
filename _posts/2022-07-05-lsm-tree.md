---
title: 'LSM Tree'
date: 2022-07-05
permalink: /posts/2022/07/lsm-tree/
tags:
  - database
  - in-memory
  - KV store
---

작년에 ICDE에서 발표된 [WipDB](https://ieeexplore.ieee.org/abstract/document/9458602)라는 논문을 보면서 LSM Tree라는 자료구조를 접했습니다. 
LSM Tree를 처음 접하는 것은 아니지만, LSM Tree라는 것이 워낙 많이 쓰이기도 하고, 이 논문과 다른 여러 논문을 읽을 때 도움이 될 것 같아 이 기회에 정리를 해보려고 합니다. 
이 글에서는 LSM Tree가 무엇인지, 어디에 쓰이는지, 어떤 변형들이 있는지 간단하게 정리할 것입니다. 

# LSM Tree

## 학부에서 인덱스에 대해 배우셨나요?

우리가 학부에서 배우는 데이터베이스 수업에서는 인덱스(index)에 대해서 배웁니다. 
먼저 인덱스에 대해서 가볍게 짚고 넘어가고자 합니다. 

### 데이터의 탐색

꼭 데이터베이스가 아니더라도, 어딘가에 데이터가 저장되어 있다면 우리는 그것을 효율적으로 탐색할 수 있어야 합니다. 
우리가 데이터를 탐색하는 가장 쉽고 직관적인 방식은 처음부터 끝까지 전체 내용을 훑어보는 것이겠죠. 
이것을 우리는 선형 탐색(linear search)이라고 부르며, O(n)의 실행 시간을 가집니다. 
만약 데이터가 정렬되어 있다면, 그 값들을 절반씩 건너뛰며 탐색을 할 수 있습니다. 
이 방법은 이진 탐색(binary search)이라고 부르고, O(log n)의 탐색 시간을 가지죠. 

하지만 어느 쪽이든 장단점이 있습니다. 
선형 탐색은 직관적이고 구현이 쉽지만, 데이터의 양이 많아질수록 비효율적이라는 단점이 있습니다. 
이진 탐색은 선형 탐색에 비해 데이터의 양에 실행 시간이 영향을 덜 받지만, 전체 데이터가 정렬되어 있어야 한다는 전제조건이 붙습니다. 
즉 이진 탐색 자체는 효율적일 수 있지만, 데이터의 순서를 정렬하고 유지하는 데에 추가적인 비용이 듭니다. 

### 인덱스

데이터베이스와 같이 많은 양의 데이터를 다룰 때에는 탐색 알고리즘만으로는 부족할 때가 많습니다. 
그래서 보통 색인, 즉 인덱스를 두죠. 
인덱스를 저장하는 데에 소모되는 추가적인 메모리를 희생해 보다 빠른 탐색 시간을 목표로 하는 것입니다. 

인덱스는 일반적으로 전체 데이터베이스의 크기보다 훨씬 작고, Key-Value의 형태로 데이터를 저장합니다. 
여기서 Key는 우리가 인덱싱하고자 하는 attribute를 저장하고, Value는 해당 Key를 가지는 tuple이 메모리 상에 위치하는 포인터를 저장합니다. 

